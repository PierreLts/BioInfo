---
title: "6. Graded assignment number 1 - population genetics and phylogeny"
author: "EPFL - SV - BIO-463"
date: 03/25/2025
date-format: long
format:
  html:
    embed-resources: true
  pdf:
    papersize: a4
    fig-width: 6
    fig-height: 4
format-links: false
---

This problem set will be graded and count for **25% of your final grade**. You can discuss with TAs and with fellow students about the problem set, but in the end you should hand in a **personal** solution. Detected plagiarism will result in a reduction of your grade.

The expected language is R, as in all the class BIO-463. Below, some R functions and libraries are recommended.

Please hand in your solution, which should contain both the R code and the accompanying explanations and answers in the same file, in **two versions**: - One should be your source file, in **.Rmd** or **.qmd** format; - The other one should be the **html** file directly deriving from your source file.

The two exercises are fully independent from each other. Each of them will be allocated the same number of points.

Some questions are broken down into itemized sub-questions. The goal is to help you address all points. Some sub-questions only require a short answer, but please make sure you answer each of them.

Please hand in your solution on **Moodle** by **Friday, March 28 at 11:59pm**.

## Exercise 1 - Evolution of HIV

Here, we will analyze the evolution of HIV sequences using the *ape: Analyses of Phylogenetics and Evolution* package and the *adegenet* package.

The data file "sequences1.fasta" contains sequences extracted from HIV genomes that were collected from one single patient, who was followed in time. The first sequence is an exception: it is not from the same patient - it is a reference sequence that was collected much earlier. The file "annot1.csv" contains annotations for these sequences. In this annotation file, the number of days after seroconversion will be of particular interest to us. Seroconversion marks the start of the development of specific antibodies in the blood serum as a result of infection.

1.  Load the sequences using *read.dna*. Load the annotations using *read.csv*, and inspect them, e.g. by displaying the first few rows of annotations.

```{r}
# Load required libraries
#install.packages("adegenet")
library(ape)
library(adegenet)

# Load the sequences
sequences <- read.dna("sequences1.fasta", format = "fasta")

# Load annotations
annotations <- read.csv("annot1.csv")

# Inspect the first few rows of annotations
head(annotations)
```

2.  In this question, we will build a phylogenetic tree for these HIV sequences:

-   Calculate all pairwise distances between sequences using *dist.dna* under the Jukes-Cantor model.
-   Next, infer a neighbor joining (NJ) tree from this list of distances using *bionj*.
-   Use the first sequence (reference) to root the tree (i.e. as outgroup) using *root*, and then use *ladderize* to transform the resulting tree.
-   Plot the tree using *plot*, annotating each leaf of the tree with the number of days after seroconversion that the sequence was collected at (using column "DaysFromSeroconversion" in the table of annotations), and representing this number of days visually by a color gradient as well as by a tip label for each leaf.

*Clue for question 2:* for visualization, you can tune figure height and width, e.g. by including the following two lines at the beginning of your code: "#\| fig-height: 20" and "#\| fig-width: 12".

```{r}
#| fig-height: 16
#| fig-width: 10

# Calculate pairwise distances using Jukes-Cantor model
dist_matrix <- dist.dna(sequences, model = "JC69")

# Infer neighbor joining tree
nj_tree <- bionj(dist_matrix)

# Root the tree using the reference sequence
rooted_tree <- root(nj_tree, outgroup = 1, resolve.root = TRUE)

# Ladderize the tree for better visualization
rooted_tree <- ladderize(rooted_tree)

# Manually expand the horizontal component of the edges
stretched_tree <- rooted_tree

# Find the reference branch index
ref_edge_idx <- which(stretched_tree$edge[,2] == 1)

# Use a moderate stretching factor
for (i in 1:nrow(stretched_tree$edge)) {
  if (i != ref_edge_idx) {
    stretched_tree$edge.length[i] <- stretched_tree$edge.length[i] * 6
  } else {
    # Slightly shorten the reference branch
    stretched_tree$edge.length[i] <- stretched_tree$edge.length[i] * 0.8
  }
}

# Get days for each tip - better matching strategy
tip_days <- numeric(length(stretched_tree$tip.label))
for (i in 1:length(stretched_tree$tip.label)) {
  current_tip <- stretched_tree$tip.label[i]
  
  # Look for substring matches in annotation names
  for (j in 1:nrow(annotations)) {
    if (grepl(annotations$Name[j], current_tip, fixed = TRUE) || 
        grepl(current_tip, annotations$Name[j], fixed = TRUE)) {
      tip_days[i] <- annotations$DaysFromSeroconversion[j]
      break
    }
  }
  
  # Special case for reference sequence
  if (grepl("HXB2", current_tip) || i == 1) {
    tip_days[i] <- NA
  }
}

# Print summary to debug
print(paste("Number of tips with assigned days:", sum(!is.na(tip_days))))
print(paste("Range of days:", min(tip_days, na.rm = TRUE), "to", max(tip_days, na.rm = TRUE)))

# Set up color gradient (correctly ordered)
library(grDevices)
# Fix the gradient: purple to magenta to orange
color_gradient <- colorRampPalette(c("#B300F2", "#DE0099", "#FF7E1D"))

# Generate colors based on days
tip_colors <- rep("darkblue", length(tip_days))  # Default for reference

# Only proceed if we have valid days
if (sum(!is.na(tip_days)) > 0) {
  max_days <- max(tip_days, na.rm = TRUE)
  min_days <- min(tip_days, na.rm = TRUE)
  
  # Scale days to 0-100 for color index (handle case where all days are the same)
  day_range <- max_days - min_days
  if (day_range > 0) {
    for (i in 1:length(tip_days)) {
      if (!is.na(tip_days[i])) {
        # Scale to 1-100 range
        scaled_value <- 1 + round(99 * (tip_days[i] - min_days) / day_range)
        tip_colors[i] <- color_gradient(100)[scaled_value]
      }
    }
  } else {
    # If all days are the same, use middle color
    tip_colors[!is.na(tip_days)] <- color_gradient(100)[50]
  }
}

# Set up plotting area with more space on the right
par(mar = c(1, 1, 3, 10), xpd = TRUE)  # Increased right margin

# Plot the stretched tree
plot(stretched_tree, show.tip.label = FALSE, 
     main = "HIV Phylogenetic Tree Colored by Days from Seroconversion",
     cex = 0.8,
     edge.width = 1.2,
     direction = "rightwards")

# Add colored dots for each tip
tiplabels(pch = 19, col = tip_colors, cex = 1.2)

# Add days labels next to the tips
tiplabels(
  text = ifelse(is.na(tip_days), "", as.character(tip_days)),
  adj = c(-0.5, 0.5),
  frame = "none",
  cex = 0.7,
  col = "black"
)

# Add "Reference" label to the reference sequence tip (should be tip 1)
# First, identify which tip number is the reference
ref_tip_index <- 1  # By convention in this dataset
# Add a special text label for the reference tip
tiplabels(
  text = "Reference",
  tip = ref_tip_index,
  adj = c(-0.2, 0.5),  # Position the text to the right of the tip
  frame = "none",
  cex = 0.9,
  col = "darkblue",
  font = 2  # Bold text
)

# SIMPLIFIED LEGEND WITHOUT FRAME AND REFERENCE
# Get plot dimensions
plot_dims <- par("usr")

# Position parameters for legend
legend_x <- plot_dims[2] * 1.03  # Positioned further to the right 
legend_y_top <- plot_dims[4] * 0.7  # Positioned in upper part
legend_width <- (plot_dims[2] - plot_dims[1]) * 0.02  # Very narrow, proportional width
legend_height <- (plot_dims[4] - plot_dims[3]) * 0.3  # Shorter height

# Increase spacing between title and gradient bar
title_spacing <- legend_width * 600  # Much larger spacing

# Add title for legend with significantly more space above the bar
text(
  legend_x + legend_width,
  legend_y_top + title_spacing,  # Greatly increased vertical space
  "Days after\nseroconversion",
  cex = 0.9,
  font = 2
)

# Draw gradient bar
gradient_x <- legend_x + legend_width/2
gradient_y_top <- legend_y_top
gradient_y_bottom <- legend_y_top - legend_height
gradient_bar_width <- legend_width/2

# Create gradient segments
num_segments <- 50  # More segments for smoother gradient
gradient_heights <- seq(gradient_y_bottom, gradient_y_top, length.out = num_segments+1)
gradient_colors <- color_gradient(num_segments)

for (i in 1:num_segments) {
  rect(
    gradient_x - gradient_bar_width,
    gradient_heights[i],
    gradient_x + gradient_bar_width,
    gradient_heights[i+1],
    col = gradient_colors[i],
    border = NA
  )
}

# Set vertical spacing between labels to avoid overlap
vertical_spacing <- legend_height / 5

# Define key day values to show with better spacing
key_days <- c(1632, 1394, 1072, 323)
ref_y_positions <- c(
  gradient_y_top,                        # 1632 (top)
  gradient_y_top - vertical_spacing,     # 1394
  gradient_y_top - 2.5*vertical_spacing, # 1072 
  gradient_y_bottom                      # 323 (bottom)
)

# Add tick marks and day labels with appropriate spacing
for (i in 1:length(key_days)) {
  day <- key_days[i]
  y_pos <- ref_y_positions[i]
  
  # Add tick mark
  segments(
    gradient_x + gradient_bar_width,
    y_pos,
    gradient_x + gradient_bar_width * 2,
    y_pos,
    lwd = 1
  )
  
  # Add day value label
  text(
    gradient_x + gradient_bar_width * 2.5,
    y_pos,
    labels = as.character(day),
    pos = 4,
    cex = 0.8,
    offset = 0.1
  )
}
```

3.  Comment on the tree obtained:

-   How are sequences collected at recent time points positioned on the tree in general?

*Sequences collected at more recent time points (Intermediate: 1072-1394 days and Late: 1632 days) tend to be positioned further from the root of the tree compared to the Early sequences (323 days). This creates a general pattern where evolutionary distance from the root correlates with time of collection, with deeper branches containing more recent sequences.*

-   What does this reflect?

*This pattern reflects the ongoing evolutionary process of HIV within this patient over time. It shows that HIV undergoes continuous genetic diversification and adaptation within a single host. This is consistent with HIV's high mutation rate and the selective pressures it faces from the host immune system. As time progresses, viral populations accumulate mutations and diverge further from the initial infecting strains.*

-   How many exceptions are there to this trend, and when were they collected (in days after seroconversion)?

*There are notable exceptions to this temporal trend:*

*9 Early sequences (all collected at 323 days post-seroconversion) appear deeper in the tree than expected for their collection time, showing greater evolutionary distance*

*4 Late sequences (collected at 1394-1632 days post-seroconversion) appear closer to the root than expected, showing less evolutionary distance*

1.  What can we conclude about these exceptions?

*These exceptions suggest several biological phenomena in HIV evolution:*

1.  ***Diverse viral population persistence:** The shallower Late sequences may represent viral lineages that remained relatively unchanged over time, possibly hiding in anatomical reservoirs with lower immune pressure or replication rates.*

2.  ***Heterogeneous evolutionary rates:** Different viral lineages within the same patient evolved at different rates, possibly due to varying selection pressures in different anatomical compartments.*

3.  ***Recombination:** HIV is known for recombination events, which could explain some sequences appearing in unexpected positions.*

4.  ***Sampling from reservoirs:** Later sampling may have captured viruses from reservoir tissues where evolution proceeds more slowly due to reduced replication.*

*The lack of monophyly for any time category further supports that HIV evolution within this patient proceeded along multiple concurrent lineages rather than in a strictly sequential manner, revealing the complex dynamics of within-host viral evolution.*

The data file "sequences2.fasta" contains sequences extracted from HIV genomes that were collected from another single patient, who was also followed in time. Again, the first sequence is an exception: it is not from the same patient - it is a reference sequence that was collected much earlier (the same as before). The file "annot2.csv" contains annotations for these sequences.

4.  Perform the same analysis as in question 2 on this data.

*Clue for question 4:* for visualization, you can tune figure height and width, e.g. by including the following two lines at the beginning of your code: "#\| fig-height: 12" and "#\| fig-width: 12".

```{r}
# Load the sequences
sequences <- read.dna("sequences2.fasta", format = "fasta")

# Load annotations
annotations <- read.csv("annot2.csv")


#| fig-height: 15
#| fig-width: 15

# Calculate pairwise distances using Jukes-Cantor model
dist_matrix <- dist.dna(sequences, model = "JC69")

# Infer neighbor joining tree
nj_tree <- bionj(dist_matrix)

# Root the tree using the reference sequence
rooted_tree <- root(nj_tree, outgroup = 1, resolve.root = TRUE)

# Ladderize the tree for better visualization
rooted_tree <- ladderize(rooted_tree)

# Manually expand the horizontal component of the edges
stretched_tree <- rooted_tree

# Find the reference branch index
ref_edge_idx <- which(stretched_tree$edge[,2] == 1)

# Use a moderate stretching factor
for (i in 1:nrow(stretched_tree$edge)) {
  if (i != ref_edge_idx) {
    stretched_tree$edge.length[i] <- stretched_tree$edge.length[i] * 6
  } else {
    # Slightly shorten the reference branch
    stretched_tree$edge.length[i] <- stretched_tree$edge.length[i] * 0.8
  }
}

# Get days for each tip - better matching strategy
tip_days <- numeric(length(stretched_tree$tip.label))
for (i in 1:length(stretched_tree$tip.label)) {
  current_tip <- stretched_tree$tip.label[i]
  
  # Look for substring matches in annotation names
  for (j in 1:nrow(annotations)) {
    if (grepl(annotations$Name[j], current_tip, fixed = TRUE) || 
        grepl(current_tip, annotations$Name[j], fixed = TRUE)) {
      tip_days[i] <- annotations$DaysFromSeroconversion[j]
      break
    }
  }
  
  # Special case for reference sequence
  if (grepl("HXB2", current_tip) || i == 1) {
    tip_days[i] <- NA
  }
}

# Print summary to debug
print(paste("Number of tips with assigned days:", sum(!is.na(tip_days))))
print(paste("Range of days:", min(tip_days, na.rm = TRUE), "to", max(tip_days, na.rm = TRUE)))

# Set up color gradient (correctly ordered)
library(grDevices)
# Fix the gradient: purple to magenta to orange
color_gradient <- colorRampPalette(c("#B300F2", "#DE0099", "#FF7E1D"))

# Generate colors based on days
tip_colors <- rep("darkblue", length(tip_days))  # Default for reference

# Only proceed if we have valid days
if (sum(!is.na(tip_days)) > 0) {
  max_days <- max(tip_days, na.rm = TRUE)
  min_days <- min(tip_days, na.rm = TRUE)
  
  # Scale days to 0-100 for color index (handle case where all days are the same)
  day_range <- max_days - min_days
  if (day_range > 0) {
    for (i in 1:length(tip_days)) {
      if (!is.na(tip_days[i])) {
        # Scale to 1-100 range
        scaled_value <- 1 + round(99 * (tip_days[i] - min_days) / day_range)
        tip_colors[i] <- color_gradient(100)[scaled_value]
      }
    }
  } else {
    # If all days are the same, use middle color
    tip_colors[!is.na(tip_days)] <- color_gradient(100)[50]
  }
}

# Set up plotting area with more space on the right
par(mar = c(1, 5, 1, 5), xpd = TRUE)  # Increased right margin

# Plot the stretched tree
plot(stretched_tree, show.tip.label = FALSE, 
     main = "HIV Phylogenetic Tree Colored by Days from Seroconversion",
     cex = 0.8,
     edge.width = 1.2,
     direction = "rightwards")

# Add colored dots for each tip
tiplabels(pch = 19, col = tip_colors, cex = 1.2)

# Add days labels next to the tips
tiplabels(
  text = ifelse(is.na(tip_days), "", as.character(tip_days)),
  adj = c(-0.5, 0.5),
  frame = "none",
  cex = 0.7,
  col = "black"
)

# Add "Reference" label to the reference sequence tip (should be tip 1)
# First, identify which tip number is the reference
ref_tip_index <- 1  # By convention in this dataset
# Add a special text label for the reference tip
tiplabels(
  text = "Reference",
  tip = ref_tip_index,
  adj = c(-0.2, 0.5),  # Position the text to the right of the tip
  frame = "none",
  cex = 0.9,
  col = "darkblue",
  font = 2  # Bold text
)

# SIMPLIFIED LEGEND WITHOUT FRAME AND REFERENCE
# Get plot dimensions
plot_dims <- par("usr")

# Position parameters for legend
legend_x <- plot_dims[2] * 1.03  # Positioned further to the right 
legend_y_top <- plot_dims[4] * 0.7  # Positioned in upper part
legend_width <- (plot_dims[2] - plot_dims[1]) * 0.02  # Very narrow, proportional width
legend_height <- (plot_dims[4] - plot_dims[3]) * 0.3  # Shorter height

# Increase spacing between title and gradient bar
title_spacing <- legend_width * 1900  # Much larger spacing

# Add title for legend with significantly more space above the bar
text(
  legend_x + legend_width,
  legend_y_top + title_spacing,  # Greatly increased vertical space
  "Days after\nseroconversion",
  cex = 0.9,
  font = 2
)

# Draw gradient bar
gradient_x <- legend_x + legend_width/2
gradient_y_top <- legend_y_top
gradient_y_bottom <- legend_y_top - legend_height
gradient_bar_width <- legend_width/2

# Create gradient segments
num_segments <- 50  # More segments for smoother gradient
gradient_heights <- seq(gradient_y_bottom, gradient_y_top, length.out = num_segments+1)
gradient_colors <- color_gradient(num_segments)

for (i in 1:num_segments) {
  rect(
    gradient_x - gradient_bar_width,
    gradient_heights[i],
    gradient_x + gradient_bar_width,
    gradient_heights[i+1],
    col = gradient_colors[i],
    border = NA
  )
}

# Set vertical spacing between labels to avoid overlap
vertical_spacing <- legend_height / 5

# Define key day values to show with better spacing
key_days <- c(199, 59, 31, 0)
ref_y_positions <- c(
  gradient_y_top,                        # 1632 (top)
  gradient_y_top - vertical_spacing,     # 1394
  gradient_y_top - 2.5*vertical_spacing, # 1072 
  gradient_y_bottom                      # 323 (bottom)
)

# Add tick marks and day labels with appropriate spacing
for (i in 1:length(key_days)) {
  day <- key_days[i]
  y_pos <- ref_y_positions[i]
  
  # Add tick mark
  segments(
    gradient_x + gradient_bar_width,
    y_pos,
    gradient_x + gradient_bar_width * 2,
    y_pos,
    lwd = 1
  )
  
  # Add day value label
  text(
    gradient_x + gradient_bar_width * 2.5,
    y_pos,
    labels = as.character(day),
    pos = 4,
    cex = 0.8,
    offset = 0.1
  )
}
```

5.  Comment on the tree obtained:

```{r}
# Reload the annotations for the second patient
annotations <- read.csv("annot2.csv")

# Find sequences with more than 100 days after seroconversion
late_sequences <- annotations[annotations$DaysFromSeroconversion > 100 & !is.na(annotations$DaysFromSeroconversion),]

# Print count and details
print("Sequences collected more than 100 days after seroconversion:")
print(paste("Count:", nrow(late_sequences)))

# Print the specific days values
print("Days after seroconversion values:")
print(unique(late_sequences$DaysFromSeroconversion))

# Print the sequence names
print("Sequence names:")
print(late_sequences$Name)

# Determine their position on the tree using previous tree data
# Calculate average distance from root for these sequences
late_seq_indices <- which(tip_days > 100)
if(length(late_seq_indices) > 0) {
  late_seq_distances <- node.depth.edgelength(stretched_tree)[late_seq_indices]
  print("Average evolutionary distance from root for late sequences:")
  print(mean(late_seq_distances))
  
  # Compare with early sequences
  early_seq_indices <- which(tip_days <= 100 & !is.na(tip_days))
  if(length(early_seq_indices) > 0) {
    early_seq_distances <- node.depth.edgelength(stretched_tree)[early_seq_indices]
    print("Average evolutionary distance from root for early sequences:")
    print(mean(early_seq_distances))
  }
}

# Extract the information about clustering
if(length(late_seq_indices) > 0) {
  print("Do late sequences form a monophyletic group?")
  # Find MRCA of late sequences
  if(length(late_seq_indices) > 1) {
    late_mrca <- getMRCA(stretched_tree, late_seq_indices)
    late_clade <- extract.clade(stretched_tree, late_mrca)
    print(paste("Monophyletic:", length(late_clade$tip.label) == length(late_seq_indices)))
  } else {
    print("Only one late sequence, cannot form a clade")
  }
}
```

-   How many sequences collected more than 100 days after seroconversion appear on the tree?

    *Only 2 sequences were collected more than 100 days after seroconversion (at days 199 and 115).*

-   Where are they positioned on the tree?

    *The late sequences are actually slightly closer to the root (average evolutionary distance 0.02414197) compared to early sequences (average distance 0.02507641).*

    *They don't form a monophyletic group, indicating they evolved independently.*

-   Is this surprising in light of the previous analysis (questions 2-3)?

    *Yes, this is very surprising. In the first patient, we observed a clear pattern where sequences collected at later time points (323-1632 days) generally had greater evolutionary distances from the root, showing ongoing divergence over time.*

    *In this second patient, we see the opposite pattern - the few late sequences are slightly closer to the root than early sequences, contrary to the expected evolutionary trajectory.*

-   Propose a hypothesis regarding the difference between these two patients.

    *The second patient dataset covers a much shorter timespan (0-199 days vs. 323-1632 days), which may be insufficient to observe directional evolution.*

    *The second patient may have begun antiretroviral therapy, which can drastically alter viral evolution by suppressing replication.*

    *The late sequences might represent viral variants reactivated from latent reservoirs containing earlier viral lineages.*

    *The second patient might have a different immune response profile, creating different selection pressures on the virus.*

    *The sampling might have been from different anatomical compartments where viral evolution proceeds at different rates.*

    *The second patient might represent a case of HIV superinfection or initial infection with multiple founder viruses with different evolutionary trajectories.*

6.  In this question, we will focus on sequences that were collected at seroconversion.

-   Extract all the sequences from this second patient that were collected at exactly 0 day after seroconversion, and form a smaller list of sequences with these sequences.
-   Extract their annotations too, in a small annotation table.
-   Calculate all pairwise distances between this subset of sequences using *dist.dna* under the Jukes-Cantor model.
-   Plot the histogram of these distances.
-   Calculate their mean and their maximum value.

```{r}
# Load required libraries
library(ape)

# Load the sequences
sequences2 <- read.dna("sequences2.fasta", format = "fasta")

# Load annotations
annotations <- read.csv("annot2.csv")

# Find sequences with 0 days after seroconversion
day0_indices <- which(annotations$DaysFromSeroconversion == 0 & !is.na(annotations$DaysFromSeroconversion))
day0_names <- annotations$Name[day0_indices]
cat("Day 0 sequences found:", length(day0_indices), "\n")

# Match sequence names to extract the correct sequences
day0_seq_indices <- numeric(0)
for (i in 1:length(attr(sequences2, "dimnames")[[1]])) {
  current_seq_name <- attr(sequences2, "dimnames")[[1]][i]
  for (day0_name in day0_names) {
    if (grepl(day0_name, current_seq_name, fixed = TRUE) || 
        grepl(current_seq_name, day0_name, fixed = TRUE)) {
      day0_seq_indices <- c(day0_seq_indices, i)
      break
    }
  }
}

cat("Matched day 0 sequences:", length(day0_seq_indices), "\n")

# Extract day 0 sequences
if (length(day0_seq_indices) >= 2) {
  day0_sequences <- sequences2[day0_seq_indices, ]
  
  # Calculate pairwise distances
  day0_distances <- dist.dna(day0_sequences, model = "JC69")
  
  # Plot histogram
  hist(day0_distances, 
       main = "Distribution of Jukes-Cantor Distances at Seroconversion (Day 0)",
       xlab = "Jukes-Cantor Distance", 
       col = "#DE0099",
       breaks = 20)
  
  # Calculate and print mean and maximum
  mean_distance <- mean(day0_distances)
  max_distance <- max(day0_distances)
  
  cat("Mean Jukes-Cantor distance:", mean_distance, "\n")
  cat("Maximum Jukes-Cantor distance:", max_distance, "\n")
} else {
  cat("Not enough day 0 sequences found for distance calculation\n")
}
```

7.  For the flu virus, the mean Jukes-Cantor distance between all sequences collected across the world in a given year is 0.008 and the maximum Jukes-Cantor distance between sequences in a given year is 0.04.

-   Compare these values to those observed in question 6, in orders of magnitude.
-   What does this tell us about HIV evolution?

*Note for question 7:* for HIV, seroconversion takes about one month after infection, and the vast majority of HIV-1 infections are initiated by a single, genetically homogeneous founder virus variant.

## Exercise 2 - Simulating experimental evolution with serial passage and mutations

*In this exercise, we will analyze the evolution of a haploid and asexual population in the long-term evolution experiment (LTEE), which is an evolution experiment on Escherichia coli bacteria, performed with serial passages. For this, let us consider a model with serial dilutions such that the population of initial size* $K$ *(bottleneck) undergoes deterministic exponential growth for a time* $t$ *and then* $K$ *individuals are selected randomly from the grown population to form the next bottleneck (serial transfer), and so on. We assume that there are two types of individuals, wild-types with fitness 1 and mutants with fitness* $1+s$*. These fitnesses represent deterministic exponential growth rates. Here, for simplicity, we will assume that all mutants have the same value of* $s$*.*

1.  *In this first question, we neglect all mutations, and thus we assume that there are only wild-type individuals in the population. In the LTEE, serial transfer is performed everyday. Population size is multiplied by 100 at the end of the day, compared to the initial bottleneck at the beginning of the day. Recall that we assume for simplicity that growth is exponential. What is the value of* $t$ *that matches the LTEE?*

*We need to determine the value of time* $t$ *that matches the LTEE conditions, where the population size is multiplied by 100 during each growth phase.*

*In the LTEE, the population undergoes exponential growth where: - Initial size:* $K$ *(bottleneck) - Final size before transfer:* $100K$ *- Growth rate for wild-type:* $r = 1$

*For exponential growth, the population size follows:*

$$N(t) = N(0) \times e^{rt}$$

*Where* $N(0) = K$ *and* $N(t) = 100K$

*Therefore:*

$$100K = K \times e^{1 \times t}$$

*Dividing both sides by* $K$*:*

$$100 = e^t$$

*Taking the natural logarithm:*

$$\ln(100) = t$$

*Let's calculate this value:*

```{r}
# Calculate the time t needed for 100-fold growth 
t = log(100) # natural logarithm 
print(paste("Time t =", round(t, 4), "generations"))
```

2.  In this question, we will consider that some mutants may be present initially, but that no new mutation may happen during the growth phase.

-   Write the mutant fraction $x'$ after growth as a function of the mutant fraction $x$ before growth and of the parameters of the system.
-   Assuming that $s=0.01$ and $x=0.01$, taking $t=5$, and taking $K=5\times 10^6$ for the bottleneck size (matching the LTEE), compute the value of $x'$.
-   Same question if all values are the same except that $s=0.5$.
-   Compare the results obtained in these two cases, and comment.

### *a) Mathematical derivation of mutant fraction after growth*

*We derive the formula for the mutant fraction after growth.*

*We denote: - Initial wild-type population:* $N_w(0) = (1-x)K$ *- Initial mutant population:* $N_m(0) = xK$

*During exponential growth with time* $t$*: - Wild-type after time* $t$*:* $N_w(t) = (1-x)K \times e^t$ *- Mutants after time* $t$*:* $N_m(t) = xK \times e^{(1+s)t}$

*The new mutant fraction* $x'$ *is:*

$$x' = \frac{N_m(t)}{N_w(t) + N_m(t)}$$

*Substituting the expressions:*

$$x' = \frac{xK \times e^{(1+s)t}}{(1-x)K \times e^t + xK \times e^{(1+s)t}}$$

*Simplifying:*

$$x' = \frac{x \times e^{(1+s)t}}{(1-x) \times e^t + x \times e^{(1+s)t}}$$

$$x' = \frac{x \times e^{st} \times e^t}{(1-x) \times e^t + x \times e^{st} \times e^t}$$

*Factoring out* $e^t$*:*

$$x' = \frac{x \times e^{st}}{(1-x) + x \times e^{st}}$$

*This is our final formula for the mutant fraction after growth.*

### *b) Calculation for specific parameter values*

```{r}
# Function to calculate mutant fraction after growth
calculate_mutant_fraction <- function(x, s, t) {
  numerator <- x * exp(s * t)
  denominator <- (1 - x) + x * exp(s * t)
  return(numerator / denominator)
}

# Case 1: s = 0.01, x = 0.01, t = 5
case1 <- calculate_mutant_fraction(0.01, 0.01, 5)
cat("Case 1 (s=0.01): x' =", case1, "\n")

# Case 2: s = 0.5, x = 0.01, t = 5
case2 <- calculate_mutant_fraction(0.01, 0.5, 5)
cat("Case 2 (s=0.5): x' =", case2, "\n")

# Calculate the ratio of increase in each case
cat("Fold increase for s=0.01:", case1/0.01, "\n")
cat("Fold increase for s=0.5:", case2/0.01, "\n")
```

### *c) Comparison and commentary*

*The results demonstrate the significant impact of selection coefficient (*$s$*) on the evolutionary dynamics:*

1.  ***With weak selection (***$s=0.01$*):*
    -   *The mutant fraction increases only slightly after growth (approximately 5% increase)*
    -   *This suggests that under weak selection, many bottleneck cycles would be needed to significantly change the population composition*
2.  ***With strong selection (***$s=0.5$*):*
    -   *The mutant fraction increases dramatically (nearly 11-fold)*
    -   *Even in a single growth cycle, strongly beneficial mutations can substantially increase in frequency*
3.  ***Implications for experimental evolution**:*
    -   *The selection coefficient is a critical parameter determining the rate of adaptation*
    -   *In the LTEE (Long-Term Evolution Experiment), mutations with larger selection coefficients would quickly sweep through the population*
    -   *For mutations with small fitness advantages, genetic drift during bottlenecks might counteract selection, requiring many more passages for fixation*
4.  ***Mathematical explanation**:*
    -   *The exponential term* $e^{st}$ *amplifies even small differences in* $s$ *over time*
    -   *This demonstrates why even small fitness advantages can eventually lead to fixation given enough time*

*This calculation illustrates why beneficial mutations with larger selection coefficients are typically observed first in evolution experiments, while those with smaller effects may take much longer to detect.*

3.  To take into account the new mutations that may happen during the growth phase, we will use the function *rflan* from the R package *flan* that allows to sample the number of mutants that descend from a given wild-type cell after a certain number of generations. Specifically, *sampled_data=rflan(N, mutations = nmu, fitness = 1/(1+s), mfn = n_grow)* provides N realizations of the number of mutants that arise from growth starting from one cell and reaching n_grow cells, where nmu mutation events happen on average and mutants have fitness 1+s. The numbers of mutants sampled are stored in *sampled_data\$mc*.

-   Use *rflan* to sample N=1000 times the final number of mutants after growth with nmu=1, s=0.01 and n_grow=100.
-   Calculate the mean and the variance of the final number of mutants over these N=1000 replicate realizations.
-   How does the variance compare to the mean?
-   What causes this?

4.  In this question, we will consider a population that starts with $K=5\times 10^6$ wild-type individuals (to match the LTEE). The population undergoes exponential growth for one day as explained in question 1. We assume that all mutants have $s=0.01$, and that one mutation event happens on average during the whole growth phase (nmu=1).

-   Simulate 10 replicates of the outcome of this growth phase (with the same initial conditions), using *rflan*. Note: this takes a bit of computational time.
-   Calculate the final fraction of mutants after growth in each case.
-   Comment on the variability of this fraction across replicates, in light of the result of question 3.

5.  In this question, we will consider a given dilution step, and we will call $k$ the number of mutants that are sampled to form the next bottleneck, which should comprise $K$ individuals.

-   What is the name of the probability distribution that $k$ follows?
-   Write the formula for the probability $P(k)$ to obtain a given value of $k$. Note: here, if possible, we recommend using LaTeX for presentation quality.

6.  In this question, we will sample the number $k$ of mutants that exist at the next bottleneck, assuming that $s=0.01$, $K=5\times 10^6$ and $x=0.01$, and taking $t=5$.

-   Sample $N=1000$ different values of $k$.
-   Compute their mean and standard deviation.
-   Plot the histogram of the values obtained.

7.  In this question, we will simulate the serial passage model. We will neglect new mutations that may happen during the process. Thus, the only mutants are those present initially, and we will assume that they have an initial fraction $x=0.01$.

-   Simulate the serial passage model described above with $s=0.01$, $K=5\times 10^6$ and $x=0.01$, and taking $t=5$, for 300 bottlenecks.
-   Plot the fraction of mutants in the population versus the number of generations in 10 different realizations on the same plot.
-   What are the characteristics and the long-term outcomes of these trajectories?
-   What is this due to?
