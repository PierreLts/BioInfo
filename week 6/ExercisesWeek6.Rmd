---
title: "6. Graded assignment number 1 - population genetics and phylogeny"
author: "EPFL - SV - BIO-463 - Pierre Lorthiois"
date: 03/25/2025
date-format: long
format:
  html:
    embed-resources: true
  pdf:
    papersize: a4
    fig-width: 6
    fig-height: 4
format-links: false
---

This problem set will be graded and count for **25% of your final grade**. You can discuss with TAs and with fellow students about the problem set, but in the end you should hand in a **personal** solution. Detected plagiarism will result in a reduction of your grade.

The expected language is R, as in all the class BIO-463. Below, some R functions and libraries are recommended.

Please hand in your solution, which should contain both the R code and the accompanying explanations and answers in the same file, in **two versions**: - One should be your source file, in **.Rmd** or **.qmd** format; - The other one should be the **html** file directly deriving from your source file.

The two exercises are fully independent from each other. Each of them will be allocated the same number of points.

Some questions are broken down into itemized sub-questions. The goal is to help you address all points. Some sub-questions only require a short answer, but please make sure you answer each of them.

Please hand in your solution on **Moodle** by **Friday, March 28 at 11:59pm**.

## Exercise 1 - Evolution of HIV

Here, we will analyze the evolution of HIV sequences using the *ape: Analyses of Phylogenetics and Evolution* package and the *adegenet* package.

The data file "sequences1.fasta" contains sequences extracted from HIV genomes that were collected from one single patient, who was followed in time. The first sequence is an exception: it is not from the same patient - it is a reference sequence that was collected much earlier. The file "annot1.csv" contains annotations for these sequences. In this annotation file, the number of days after seroconversion will be of particular interest to us. Seroconversion marks the start of the development of specific antibodies in the blood serum as a result of infection.

1.  Load the sequences using *read.dna*. Load the annotations using *read.csv*, and inspect them, e.g. by displaying the first few rows of annotations.

```{r}
# Load libraries
library(ape)
library(adegenet)

# Load the sequences
sequences <- read.dna("sequences1.fasta", format = "fasta")

# Load annotations
annotations <- read.csv("annot1.csv")

# Print the first few rows of annotations
head(annotations)
```

2.  In this question, we will build a phylogenetic tree for these HIV sequences:

-   Calculate all pairwise distances between sequences using *dist.dna* under the Jukes-Cantor model.
-   Next, infer a neighbor joining (NJ) tree from this list of distances using *bionj*.
-   Use the first sequence (reference) to root the tree (i.e. as outgroup) using *root*, and then use *ladderize* to transform the resulting tree.
-   Plot the tree using *plot*, annotating each leaf of the tree with the number of days after seroconversion that the sequence was collected at (using column "DaysFromSeroconversion" in the table of annotations), and representing this number of days visually by a color gradient as well as by a tip label for each leaf.

*Clue for question 2:* for visualization, you can tune figure height and width, e.g. by including the following two lines at the beginning of your code: "#\| fig-height: 20" and "#\| fig-width: 12".

```{r}
#| fig-height: 36
#| fig-width: 25

# Calculate pairwise distances using Jukes-Cantor model
dist_matrix <- dist.dna(sequences, model = "JC69")

# Infer neighbor joining tree
nj_tree <- bionj(dist_matrix)

# Root the tree using the reference sequence
rooted_tree <- root(nj_tree, outgroup = 1, resolve.root = TRUE)

# Ladderize the tree for better visualization
rooted_tree <- ladderize(rooted_tree)

# Manually expand the horizontal component of the edges
stretched_tree <- rooted_tree

# Find the reference branch index
ref_edge_idx <- which(stretched_tree$edge[,2] == 1)

# Stretching the tree for better visualization
for (i in 1:nrow(stretched_tree$edge)) {
  if (i != ref_edge_idx) {
    stretched_tree$edge.length[i] <- stretched_tree$edge.length[i] * 8
  } else {
    # Slightly shorten the reference branch
    stretched_tree$edge.length[i] <- stretched_tree$edge.length[i] * 0.8
  }
}

# Get days for each tip - better matching strategy
tip_days <- numeric(length(stretched_tree$tip.label))
for (i in 1:length(stretched_tree$tip.label)) {
  current_tip <- stretched_tree$tip.label[i]
  
  # Look for substring matches in annotation names
  for (j in 1:nrow(annotations)) {
    if (grepl(annotations$Name[j], current_tip, fixed = TRUE) || 
        grepl(current_tip, annotations$Name[j], fixed = TRUE)) {
      tip_days[i] <- annotations$DaysFromSeroconversion[j]
      break
    }
  }
  
  # Special case for reference sequence
  if (grepl("HXB2", current_tip) || i == 1) {
    tip_days[i] <- NA
  }
}

# Print summary to debug
print(paste("Number of tips with assigned days:", sum(!is.na(tip_days))))
print(paste("Range of days:", min(tip_days, na.rm = TRUE), "to", max(tip_days, na.rm = TRUE)))

# Set up color gradient (correctly ordered)
library(grDevices)
# Fix the gradient: purple to magenta to orange
color_gradient <- colorRampPalette(c("#B300F2", "#DE0099", "#FF7E1D"))

# Generate colors based on days
tip_colors <- rep("#0066FF", length(tip_days))  # Default for reference

# Only proceed if we have valid days
if (sum(!is.na(tip_days)) > 0) {
  max_days <- max(tip_days, na.rm = TRUE)
  min_days <- min(tip_days, na.rm = TRUE)
  
  # Scale days to 0-100 for color index (handle case where all days are the same)
  day_range <- max_days - min_days
  if (day_range > 0) {
    for (i in 1:length(tip_days)) {
      if (!is.na(tip_days[i])) {
        # Scale to 1-100 range
        scaled_value <- 1 + round(99 * (tip_days[i] - min_days) / day_range)
        tip_colors[i] <- color_gradient(100)[scaled_value]
      }
    }
  } else {
    # If all days are the same, use middle color
    tip_colors[!is.na(tip_days)] <- color_gradient(100)[50]
  }
}

# Set up plotting area with more space on the right
par(mar = c(1, 1, 3, 15), xpd = TRUE)  # Increased right margin

# Plot the stretched tree
plot(stretched_tree, show.tip.label = FALSE, 
     main = "HIV Phylogenetic Tree Colored by Days from Seroconversion (1)",
     cex.main = 3.5,
     cex = 2.5,
     edge.width = 3,
     direction = "rightwards")

# Add colored dots for each tip
tiplabels(pch = 19, col = tip_colors, cex = 3)

# Add days labels next to the tips
tiplabels(
  text = ifelse(is.na(tip_days), "", as.character(tip_days)),
  adj = c(-0.5, 0.5),
  frame = "none",
  cex = 2.2,
  col = "black"
)

# Add "Reference" label to the reference sequence tip (should be tip 1)
# First, identify which tip number is the reference
ref_tip_index <- 1  # By convention in this dataset
# Add a special text label for the reference tip
tiplabels(
  text = "Reference",
  tip = ref_tip_index,
  adj = c(-0.2, 0.5),  # Position the text to the right of the tip
  frame = "none",
  cex = 2.5,
  col = "#0066FF",
  font = 2  # Bold text
)

# LEGEND
# Get plot dimensions
plot_dims <- par("usr")

# Position parameters for legend
legend_x <- plot_dims[2] * 1  # Positioned further to the right 
legend_y_top <- plot_dims[4] * 0.7  # Positioned in upper part
legend_width <- (plot_dims[2] - plot_dims[1]) * 0.02  # Very narrow, proportional width
legend_height <- (plot_dims[4] - plot_dims[3]) * 0.25  # Shorter height

# Increase spacing between title and gradient bar
title_spacing <- legend_width * 700  # Much larger spacing

# Add title for legend with significantly more space above the bar
text(
  legend_x + legend_width,
  legend_y_top + title_spacing,  # Greatly increased vertical space
  "Days after\nseroconversion",
  cex = 2.5,
  font = 2
)

# Draw gradient bar
gradient_x <- legend_x + legend_width/2
gradient_y_top <- legend_y_top
gradient_y_bottom <- legend_y_top - legend_height
gradient_bar_width <- legend_width/2

# Create gradient segments
num_segments <- 50  # Smooth gradient
gradient_heights <- seq(gradient_y_bottom, gradient_y_top, length.out = num_segments+1)
gradient_colors <- color_gradient(num_segments)

for (i in 1:num_segments) {
  rect(
    gradient_x - gradient_bar_width,
    gradient_heights[i],
    gradient_x + gradient_bar_width,
    gradient_heights[i+1],
    col = gradient_colors[i],
    border = NA
  )
}

# Define key day values to show
key_days <- c(1632, 1394, 1072, 323)
ref_y_positions <- c(
  gradient_y_top,                               # 1632 (top)
  gradient_y_top - (1-1394/1632)*legend_height, # 1394
  gradient_y_top - (1-1072/1632)*legend_height, # 1072 
  gradient_y_bottom                             # 323 (bottom)
)

# Add tick marks and day labels with appropriate spacing
for (i in 1:length(key_days)) {
  day <- key_days[i]
  y_pos <- ref_y_positions[i]
  
  # Add tick mark
  segments(
    gradient_x + gradient_bar_width,
    y_pos,
    gradient_x + gradient_bar_width * 2,
    y_pos,
    lwd = 1
  )
  
  # Add day value label
  text(
    gradient_x + gradient_bar_width * 2.5,
    y_pos,
    labels = as.character(day),
    pos = 4,
    cex = 2.5,
    offset = 0.1
  )
}
```

3.  Comment on the tree obtained:

-   How are sequences collected at recent time points positioned on the tree in general?

[Sequences collected at more recent time points (Intermediate: 1072-1394 days and Late: 1632 days) tend to be positioned further from the root of the tree compared to the Early sequences (323 days). This creates a general pattern where evolutionary distance from the root correlates with time of collection, with deeper branches containing more recent sequences.]{style="color:#0066FF;"}

-   What does this reflect?

[This pattern reflects the ongoing evolutionary process of HIV within this patient over time. It shows that HIV undergoes continuous genetic diversification and adaptation within a single host. This is consistent with HIV's high mutation rate and the selective pressures it faces from the host immune system. As time progresses, viral populations accumulate mutations and diverge further from the initial infecting strains.]{style="color:#0066FF;"}

-   How many exceptions are there to this trend, and when were they collected (in days after seroconversion)?

[There are notable exceptions to this temporal trend:]{style="color:#0066FF;"}

[9 Early sequences (all collected at 323 days post-seroconversion) appear deeper in the tree than expected for their collection time, showing greater evolutionary distance]{style="color:#0066FF;"}

[4 Late sequences (collected at 1394-1632 days post-seroconversion) appear closer to the root than expected, showing less evolutionary distance]{style="color:#0066FF;"}

-   What can we conclude about these exceptions?

[These exceptions suggest several biological phenomena in HIV evolution:]{style="color:#0066FF;"}

[1. **Diverse viral population persistence:** The shallower Late sequences may represent viral lineages that remained relatively unchanged over time, possibly hiding in anatomical reservoirs with lower immune pressure or replication rates.]{style="color:#0066FF;"}

[2. **Heterogeneous evolutionary rates:** Different viral lineages within the same patient evolved at different rates, possibly due to varying selection pressures in different anatomical compartments.]{style="color:#0066FF;"}

[3. **Recombination:** HIV is known for recombination events, which could explain some sequences appearing in unexpected positions.]{style="color:#0066FF;"}

[4. **Sampling from reservoirs:** Later sampling may have captured viruses from reservoir tissues where evolution proceeds more slowly due to reduced replication.]{style="color:#0066FF;"}

[The lack of monophyly for any time category further supports that HIV evolution within this patient proceeded along multiple concurrent lineages rather than in a strictly sequential manner, revealing the complex dynamics of within-host viral evolution.]{style="color:#0066FF;"}

The data file "sequences2.fasta" contains sequences extracted from HIV genomes that were collected from another single patient, who was also followed in time. Again, the first sequence is an exception: it is not from the same patient - it is a reference sequence that was collected much earlier (the same as before). The file "annot2.csv" contains annotations for these sequences.

4.  Perform the same analysis as in question 2 on this data.

*Clue for question 4:* for visualization, you can tune figure height and width, e.g. by including the following two lines at the beginning of your code: "#\| fig-height: 12" and "#\| fig-width: 12".

```{r}
#| fig-height: 25
#| fig-width: 25

# Load the sequences
sequences <- read.dna("sequences2.fasta", format = "fasta")

# Load annotations
annotations <- read.csv("annot2.csv")


# Calculate pairwise distances using Jukes-Cantor model
dist_matrix <- dist.dna(sequences, model = "JC69")

# Infer neighbor joining tree
nj_tree <- bionj(dist_matrix)

# Root the tree using the reference sequence
rooted_tree <- root(nj_tree, outgroup = 1, resolve.root = TRUE)

# Ladderize the tree for better visualization
rooted_tree <- ladderize(rooted_tree)

# Manually expand the horizontal component of the edges
stretched_tree <- rooted_tree

# Stretching the tree for better visualization
ref_edge_idx <- which(stretched_tree$edge[,2] == 1)

# Use a moderate stretching factor
for (i in 1:nrow(stretched_tree$edge)) {
  if (i != ref_edge_idx) {
    stretched_tree$edge.length[i] <- stretched_tree$edge.length[i] * 4
  } else {
    # Slightly shorten the reference branch
    stretched_tree$edge.length[i] <- stretched_tree$edge.length[i] * 0.3
  }
}

# Get days for each tip - better matching strategy
tip_days <- numeric(length(stretched_tree$tip.label))
for (i in 1:length(stretched_tree$tip.label)) {
  current_tip <- stretched_tree$tip.label[i]
  
  # Look for substring matches in annotation names
  for (j in 1:nrow(annotations)) {
    if (grepl(annotations$Name[j], current_tip, fixed = TRUE) || 
        grepl(current_tip, annotations$Name[j], fixed = TRUE)) {
      tip_days[i] <- annotations$DaysFromSeroconversion[j]
      break
    }
  }
  
  # Special case for reference sequence
  if (grepl("HXB2", current_tip) || i == 1) {
    tip_days[i] <- NA
  }
}

# Print summary to debug
print(paste("Number of tips with assigned days:", sum(!is.na(tip_days))))
print(paste("Range of days:", min(tip_days, na.rm = TRUE), "to", max(tip_days, na.rm = TRUE)))

# Set up color gradient
library(grDevices)
# Fix the gradient: purple to magenta to orange
color_gradient <- colorRampPalette(c("#B300F2", "#DE0099", "#FF7E1D"))

# Generate colors based on days
tip_colors <- rep("#0066FF", length(tip_days))  # Default for reference

# Only proceed if we have valid days
if (sum(!is.na(tip_days)) > 0) {
  max_days <- max(tip_days, na.rm = TRUE)
  min_days <- min(tip_days, na.rm = TRUE)
  
  # Scale days to 0-100 for color index (handle case where all days are the same)
  day_range <- max_days - min_days
  if (day_range > 0) {
    for (i in 1:length(tip_days)) {
      if (!is.na(tip_days[i])) {
        # Scale to 1-100 range
        scaled_value <- 1 + round(99 * (tip_days[i] - min_days) / day_range)
        tip_colors[i] <- color_gradient(100)[scaled_value]
      }
    }
  } else {
    # If all days are the same, use middle color
    tip_colors[!is.na(tip_days)] <- color_gradient(100)[50]
  }
}

# Set up plotting area with more space on the right
par(mar = c(1, 5, 10, 20), xpd = TRUE)  # Increased right margin

# Plot the stretched tree
plot(stretched_tree, show.tip.label = FALSE, 
     main = "HIV Phylogenetic Tree Colored by Days from Seroconversion (2)",
     cex.main = 3.5,
     cex = 2.5,
     edge.width = 3,
     direction = "rightwards")

# Add colored dots for each tip
tiplabels(pch = 19, col = tip_colors, cex = 3)

# Add days labels next to the tips
tiplabels(
  text = ifelse(is.na(tip_days), "", as.character(tip_days)),
  adj = c(-0.8, 0.5),
  frame = "none",
  cex = 2.5,
  col = "black"
)

# Add "Reference" label to the reference sequence tip (should be tip 1)
# First, identify which tip number is the reference
ref_tip_index <- 1  # By convention in this dataset
# Add a special text label for the reference tip
tiplabels(
  text = "Reference",
  tip = ref_tip_index,
  adj = c(-0.2, 0.5),  # Position the text to the right of the tip
  frame = "none",
  cex = 2.5,
  col = "#0066FF",
  font = 2  # Bold text
)

# LEGEND
# Get plot dimensions
plot_dims <- par("usr")

# Position parameters for legend
legend_x <- plot_dims[2] * 0.9  # Positioned further to the right 
legend_y_top <- plot_dims[4] * 0.7  # Positioned in upper part
legend_width <- (plot_dims[2] - plot_dims[1]) * 0.025  # narrow, proportional width
legend_height <- (plot_dims[4] - plot_dims[3]) * 0.35  # height

# Increase spacing between title and gradient bar
title_spacing <- legend_width * 1700

# Add title for legend with significantly more space above the bar
text(
  legend_x + legend_width,
  legend_y_top + title_spacing,  # Greatly increased vertical space
  "Days after\nseroconversion",
  cex = 2.5,
  font = 2
)

# Draw gradient bar
gradient_x <- legend_x + legend_width/2
gradient_y_top <- legend_y_top
gradient_y_bottom <- legend_y_top - legend_height
gradient_bar_width <- legend_width/2

# Create gradient segments
num_segments <- 50  # Smooth gradient
gradient_heights <- seq(gradient_y_bottom, gradient_y_top, length.out = num_segments+1)
gradient_colors <- color_gradient(num_segments)

for (i in 1:num_segments) {
  rect(
    gradient_x - gradient_bar_width,
    gradient_heights[i],
    gradient_x + gradient_bar_width,
    gradient_heights[i+1],
    col = gradient_colors[i],
    border = NA
  )
}


# Define key day values to show with better spacing
key_days <- c(199, 115, 59, 31, 0)
ref_y_positions <- c(
  gradient_y_top,                             # 199 (top)
  gradient_y_top - (1-115/199)*legend_height, # 115
  gradient_y_top - (1-59/199)*legend_height,  # 59 
  gradient_y_top - (1-31/199)*legend_height,  # 31
  gradient_y_bottom                           # 0 (bottom)
)

# Add tick marks and day labels with appropriate spacing
for (i in 1:length(key_days)) {
  day <- key_days[i]
  y_pos <- ref_y_positions[i]
  
  # Add tick mark
  segments(
    gradient_x + gradient_bar_width,
    y_pos,
    gradient_x + gradient_bar_width * 2,
    y_pos,
    lwd = 1
  )
  
  # Add day value label
  text(
    gradient_x + gradient_bar_width * 2.5,
    y_pos,
    labels = as.character(day),
    pos = 4,
    cex = 2.5,
    offset = 0.1
  )
}
```

5.  Comment on the tree obtained:

```{r}
# Reload the annotations for the second patient
annotations <- read.csv("annot2.csv")

# Find sequences with more than 100 days after seroconversion
late_sequences <- annotations[annotations$DaysFromSeroconversion > 100 & !is.na(annotations$DaysFromSeroconversion),]

# Print count and details
print("Sequences collected more than 100 days after seroconversion:")
print(paste("Count:", nrow(late_sequences)))

# Print the specific days values
print("Days after seroconversion values:")
print(unique(late_sequences$DaysFromSeroconversion))

# Print the sequence names
print("Sequence names:")
print(late_sequences$Name)

# Determine their position on the tree using previous tree data
# Calculate average distance from root for these sequences
late_seq_indices <- which(tip_days > 100)
if(length(late_seq_indices) > 0) {
  late_seq_distances <- node.depth.edgelength(stretched_tree)[late_seq_indices]
  print("Average evolutionary distance from root for late sequences:")
  print(mean(late_seq_distances))
  
  # Compare with early sequences
  early_seq_indices <- which(tip_days <= 100 & !is.na(tip_days))
  if(length(early_seq_indices) > 0) {
    early_seq_distances <- node.depth.edgelength(stretched_tree)[early_seq_indices]
    print("Average evolutionary distance from root for early sequences:")
    print(mean(early_seq_distances))
  }
}

# Extract the information about clustering
if(length(late_seq_indices) > 0) {
  print("Do late sequences form a monophyletic group?")
  # Find MRCA of late sequences
  if(length(late_seq_indices) > 1) {
    late_mrca <- getMRCA(stretched_tree, late_seq_indices)
    late_clade <- extract.clade(stretched_tree, late_mrca)
    print(paste("Monophyletic:", length(late_clade$tip.label) == length(late_seq_indices)))
  } else {
    print("Only one late sequence, cannot form a clade")
  }
}
```

-   How many sequences collected more than 100 days after seroconversion appear on the tree?

    [Only 2 sequences were collected more than 100 days after seroconversion (at days 199 and 115).]{style="color:#0066FF;"}

-   Where are they positioned on the tree?

    [The late sequences are actually slightly closer to the root (average evolutionary distance 0.04023662) compared to early sequences (average distance 0.04179402).]{style="color:#0066FF;"}

    [They don't form a monophyletic group, indicating they evolved independently.]{style="color:#0066FF;"}

-   Is this surprising in light of the previous analysis (questions 2-3)?

    [Yes, this is very surprising. In the first patient, we observed a clear pattern where sequences collected at later time points (323-1632 days) generally had greater evolutionary distances from the root, showing ongoing divergence over time.]{style="color:#0066FF;"}

    [In this second patient, we see the opposite pattern - the few late sequences are slightly closer to the root than early sequences, contrary to the expected evolutionary trajectory.]{style="color:#0066FF;"}

-   Propose a hypothesis regarding the difference between these two patients.

    [The second patient dataset covers a much shorter timespan (0-199 days vs. 323-1632 days), which may be insufficient to observe directional evolution.]{style="color:#0066FF;"}

    [The second patient may have begun antiretroviral therapy, which can drastically alter viral evolution by suppressing replication.]{style="color:#0066FF;"}

    [The late sequences might represent viral variants reactivated from latent reservoirs containing earlier viral lineages.]{style="color:#0066FF;"}

    [The second patient might have a different immune response profile, creating different selection pressures on the virus.]{style="color:#0066FF;"}

    [The sampling might have been from different anatomical compartments where viral evolution proceeds at different rates.]{style="color:#0066FF;"}

6.  In this question, we will focus on sequences that were collected at seroconversion.

-   Extract all the sequences from this second patient that were collected at exactly 0 day after seroconversion, and form a smaller list of sequences with these sequences.
-   Extract their annotations too, in a small annotation table.
-   Calculate all pairwise distances between this subset of sequences using *dist.dna* under the Jukes-Cantor model.
-   Plot the histogram of these distances.
-   Calculate their mean and their maximum value.

```{r}
library(ape)

# Load the data
sequences2 <- read.dna("sequences2.fasta", format = "fasta")
annotations <- read.csv("annot2.csv")

# Sequences with 0 days after seroconversion
day0_indices <- which(annotations$DaysFromSeroconversion == 0 & !is.na(annotations$DaysFromSeroconversion))
day0_names <- annotations$Name[day0_indices]
cat("Day 0 sequences found:", length(day0_indices), "\n")

# Match sequence names to extract the correct sequences
day0_seq_indices <- numeric(0)
for (i in 1:length(attr(sequences2, "dimnames")[[1]])) {
  current_seq_name <- attr(sequences2, "dimnames")[[1]][i]
  for (day0_name in day0_names) {
    if (grepl(day0_name, current_seq_name, fixed = TRUE) || 
        grepl(current_seq_name, day0_name, fixed = TRUE)) {
      day0_seq_indices <- c(day0_seq_indices, i)
      break
    }
  }
}

cat("Matched day 0 sequences:", length(day0_seq_indices), "\n")

# Extract day 0 sequences
if (length(day0_seq_indices) >= 2) {
  day0_sequences <- sequences2[day0_seq_indices, ]
  
  # Calculate pairwise distances
  day0_distances <- dist.dna(day0_sequences, model = "JC69")
  
  # Plot histogram
  hist(day0_distances, 
       main = "Distribution of Jukes-Cantor Distances at Seroconversion (Day 0)",
       xlab = "Jukes-Cantor Distance", 
       col = "#FF7E1D",
       breaks = 20)
  
  # Calculate and print mean and maximum
  mean_distance <- mean(day0_distances)
  max_distance <- max(day0_distances)
  
  cat("Mean Jukes-Cantor distance:", mean_distance, "\n")
  cat("Maximum Jukes-Cantor distance:", max_distance, "\n")
} else {
  cat("Not enough day 0 sequences found for distance calculation\n")
}
```

7.  For the flu virus, the mean Jukes-Cantor distance between all sequences collected across the world in a given year is 0.008 and the maximum Jukes-Cantor distance between sequences in a given year is 0.04.

-   Compare these values to those observed in question 6, in orders of magnitude.

*Note for question 7:* for HIV, seroconversion takes about one month after infection, and the vast majority of HIV-1 infections are initiated by a single, genetically homogeneous founder virus variant.

```{r}
# Given flu virus values
flu_mean_distance <- 0.008
flu_max_distance <- 0.04

# Our HIV values at seroconversion (day 0)
hiv_mean_distance <- 0.004534841
hiv_max_distance <- 0.01065449

# Calculate ratios for comparison
mean_ratio <- flu_mean_distance / hiv_mean_distance
max_ratio <- flu_max_distance / hiv_max_distance

cat("Comparison of genetic distances between HIV at seroconversion and flu in one year:\n")
cat("Mean distances: HIV =", hiv_mean_distance, "vs Flu =", flu_mean_distance, "\n")
cat("Ratio of means (Flu/HIV):", mean_ratio, "\n\n")
cat("Maximum distances: HIV =", hiv_max_distance, "vs Flu =", flu_max_distance, "\n")
cat("Ratio of maximums (Flu/HIV):", max_ratio, "\n")
```

-   What does this tell us about HIV evolution?

[**HIV vs. Flu Evolution**]{style="color:#0066FF;"}

[The comparison between HIV at seroconversion and global flu samples over a year reveals striking differences in viral evolution:]{style="color:#0066FF;"}

[- **Mean genetic distance comparison**: HIV at seroconversion (0.0045) vs. Flu over a year (0.008) The flu mean is about 1.8 times larger than HIV]{style="color:#0066FF;"}

[- **Maximum genetic distance comparison**: HIV at seroconversion (0.0107) vs. Flu over a year (0.04) The flu maximum is about 3.7 times larger than HIV]{style="color:#0066FF;"}

[This tells us several important things about HIV evolution:]{style="color:#0066FF;"}

[1. Rapid diversification:]{style="color:#0066FF;"}

[Despite starting from a single founder virus just one month before seroconversion, HIV already shows substantial genetic diversity, more than half the mean diversity seen in global flu samples over an entire year.]{style="color:#0066FF;"}

[2. High mutation rate:]{style="color:#0066FF;"}

[HIV's reverse transcriptase lacks proofreading capability, resulting in a high mutation rate that leads to this rapid within-host diversification early in infection.]{style="color:#0066FF;"}

[3. Early quasispecies formation:]{style="color:#0066FF;"}

[The bimodal distribution in the histogram suggests that HIV forms distinct viral populations (quasispecies) very early in infection, with many sequences showing very small distances (likely recent descendants from the founder virus) and another peak at greater distances (early adaptations).]{style="color:#0066FF;"}

[4. Different evolutionary pressures:]{style="color:#0066FF;"}

[While flu evolves under selection pressure to escape population-level immunity across multiple hosts, HIV diversifies rapidly within a single host, reflecting its strategy of generating high variability to escape the developing immune response.]{style="color:#0066FF;"}

[The substantial diversity observed at seroconversion shows HIV's capacity for evolutionary adaptation, explaining its ability to persist despite immune responses and develop resistance to antiretroviral drugs.]{style="color:#0066FF;"}

## Exercise 2 - Simulating experimental evolution with serial passage and mutations

*In this exercise, we will analyze the evolution of a haploid and asexual population in the long-term evolution experiment (LTEE), which is an evolution experiment on Escherichia coli bacteria, performed with serial passages. For this, let us consider a model with serial dilutions such that the population of initial size* $K$ *(bottleneck) undergoes deterministic exponential growth for a time* $t$ *and then* $K$ *individuals are selected randomly from the grown population to form the next bottleneck (serial transfer), and so on. We assume that there are two types of individuals, wild-types with fitness 1 and mutants with fitness* $1+s$*. These fitnesses represent deterministic exponential growth rates. Here, for simplicity, we will assume that all mutants have the same value of* $s$*.*

1.  *In this first question, we neglect all mutations, and thus we assume that there are only wild-type individuals in the population. In the LTEE, serial transfer is performed everyday. Population size is multiplied by 100 at the end of the day, compared to the initial bottleneck at the beginning of the day. Recall that we assume for simplicity that growth is exponential. What is the value of* $t$ *that matches the LTEE?*

[In the LTEE, the population undergoes exponential growth where:]{style="color:#0066FF;"}

[- Initial size: $K$ (bottleneck)]{style="color:#0066FF;"}

[- Final size before transfer: $100K$]{style="color:#0066FF;"}

[- Growth rate for wild-type: $r = 1$]{style="color:#0066FF;"}

[For exponential growth, the population size follows:]{style="color:#0066FF;"}

[$$N(t) = N(0) \times e^{rt}$$]{style="color:#0066FF;"}

[Where $N(0) = K$ and $N(t) = 100K$]{style="color:#0066FF;"}

[Therefore:]{style="color:#0066FF;"}

[$$100K = K \times e^{1 \times t}$$]{style="color:#0066FF;"}

[Dividing both sides by $K$:]{style="color:#0066FF;"}

[$$100 = e^t$$]{style="color:#0066FF;"}

[Taking the natural logarithm:]{style="color:#0066FF;"}

[$$\ln(100) = t$$]{style="color:#0066FF;"}

[Calculating this value:]{style="color:#0066FF;"}

```{r}
# Calculate the time t needed for 100-fold growth 
t = log(100) # natural logarithm 
print(paste("Time t =", round(t, 4), "generations"))
```

2.  In this question, we will consider that some mutants may be present initially, but that no new mutation may happen during the growth phase.

-   Write the mutant fraction $x'$ after growth as a function of the mutant fraction $x$ before growth and of the parameters of the system.

[We derive the formula for the mutant fraction after growth.]{style="color:#0066FF;"}

[We denote:]{style="color:#0066FF;"}

[- Initial wild-type population: $N_w(0) = (1-x)K$]{style="color:#0066FF;"}

[- Initial mutant population: $N_m(0) = xK$]{style="color:#0066FF;"}

[During exponential growth with time $t$: ]{style="color:#0066FF;"}

[- Wild-type after time $t$: $N_w(t) = (1-x)K \times e^t$ ]{style="color:#0066FF;"}

[- Mutants after time $t$: $N_m(t) = xK \times e^{(1+s)t}$]{style="color:#0066FF;"}

[The new mutant fraction $x'$ is:]{style="color:#0066FF;"}

[$$x' = \frac{N_m(t)}{N_w(t) + N_m(t)}$$]{style="color:#0066FF;"}

[Substituting the expressions:]{style="color:#0066FF;"}

[$$x' = \frac{xK \times e^{(1+s)t}}{(1-x)K \times e^t + xK \times e^{(1+s)t}}$$]{style="color:#0066FF;"}

[Simplifying:]{style="color:#0066FF;"}

[$$x' = \frac{x \times e^{(1+s)t}}{(1-x) \times e^t + x \times e^{(1+s)t}}$$]{style="color:#0066FF;"}

[$$x' = \frac{x \times e^{st} \times e^t}{(1-x) \times e^t + x \times e^{st} \times e^t}$$]{style="color:#0066FF;"}

[Factoring out $e^t$:]{style="color:#0066FF;"}

[$$x' = \frac{x \times e^{st}}{(1-x) + x \times e^{st}}$$]{style="color:#0066FF;"}

[This is our final formula for the mutant fraction after growth.]{style="color:#0066FF;"}

-   Assuming that $s=0.01$ and $x=0.01$, taking $t=5$, and taking $K=5\times 10^6$ for the bottleneck size (matching the LTEE), compute the value of $x'$.
-   Same question if all values are the same except that $s=0.5$.

```{r}
# Function to calculate mutant fraction after growth
calculate_mutant_fraction <- function(x, s, t) {
  numerator <- x * exp(s * t)
  denominator <- (1 - x) + x * exp(s * t)
  return(numerator / denominator)
}

# Case 1: s = 0.01, x = 0.01, t = 5
case1 <- calculate_mutant_fraction(0.01, 0.01, 5)
cat("Case 1 (s=0.01): x' =", case1, "\n")

# Case 2: s = 0.5, x = 0.01, t = 5
case2 <- calculate_mutant_fraction(0.01, 0.5, 5)
cat("Case 2 (s=0.5): x' =", case2, "\n")

# Calculate the ratio of increase in each case
cat("Fold increase for s=0.01:", case1/0.01, "\n")
cat("Fold increase for s=0.5:", case2/0.01, "\n")
```

-   Compare the results obtained in these two cases, and comment.

[The results demonstrate the significant impact of selection coefficient ($s$) on the evolutionary dynamics:]{style="color:#0066FF;"}

[**1. With weak selection (**$s=0.01$**):** ]{style="color:#0066FF;"}

[- The mutant fraction increases from 0.01 to 0.01050732, which is precisely a 5.0732% increase ]{style="color:#0066FF;"}

[- The fold increase is exactly 1.050732 ]{style="color:#0066FF;"}

[- This suggests that under weak selection, many bottleneck cycles would be needed to significantly change the population composition]{style="color:#0066FF;"}

[**2. With strong selection (**$s=0.5$**):**]{style="color:#0066FF;"}

[- The mutant fraction increases from 0.01 to 0.1095721, which is a 10.95721-fold increase]{style="color:#0066FF;"}

[- In percentage terms, this represents a dramatic 995.721% increase]{style="color:#0066FF;"}

[- Even in a single growth cycle, strongly beneficial mutations can substantially increase in frequency]{style="color:#0066FF;"}

[**3. Implications for experimental evolution:**]{style="color:#0066FF;"}

[- The selection coefficient is a critical parameter determining the rate of adaptation]{style="color:#0066FF;"}

[- In the LTEE (Long-Term Evolution Experiment), mutations with larger selection coefficients would quickly sweep through the population]{style="color:#0066FF;"}

[- For mutations with small fitness advantages (like $s=0.01$), genetic drift during bottlenecks might counteract selection, requiring many more passages for fixation]{style="color:#0066FF;"}

[- Mutations with large fitness advantages (like $s=0.5$) would be expected to dominate even after a few cycles]{style="color:#0066FF;"}

[**4. Mathematical explanation:**]{style="color:#0066FF;"}

[- The exponential term $e^{st}$ amplifies even small differences in $s$ over time]{style="color:#0066FF;"}

[- For $s=0.01$ and $t=5$, we get $e^{0.01 \times 5} = e^{0.05} \approx 1.0513$]{style="color:#0066FF;"}

[- For $s=0.5$ and $t=5$, we get $e^{0.5 \times 5} = e^{2.5} \approx 12.1825$]{style="color:#0066FF;"}

[- This demonstrates why even small fitness advantages can eventually lead to fixation given enough time, while large fitness advantages lead to rapid change]{style="color:#0066FF;"}

[This calculation illustrates why beneficial mutations with larger selection coefficients are typically observed first in evolution experiments, while those with smaller effects may take much longer to detect.]{style="color:#0066FF;"}

3.  To take into account the new mutations that may happen during the growth phase, we will use the function *rflan* from the R package *flan* that allows to sample the number of mutants that descend from a given wild-type cell after a certain number of generations. Specifically, *sampled_data=rflan(N, mutations = nmu, fitness = 1/(1+s), mfn = n_grow)* provides N realizations of the number of mutants that arise from growth starting from one cell and reaching n_grow cells, where nmu mutation events happen on average and mutants have fitness 1+s. The numbers of mutants sampled are stored in *sampled_data\$mc*.

-   Use *rflan* to sample N=1000 times the final number of mutants after growth with nmu=1, s=0.01 and n_grow=100.
-   Calculate the mean and the variance of the final number of mutants over these N=1000 replicate realizations.

```{r}
# Install and load the flan package if not already installed
if (!requireNamespace("flan", quietly = TRUE)) {
  install.packages("flan")
}
library(flan)

# Sample 1000 times the final number of mutants
set.seed(123) # For reproducibility
N <- 1000
nmu <- 1
s <- 0.01
n_grow <- 100

sampled_data <- rflan(N, mutations = nmu, fitness = 1/(1+s), mfn = n_grow)

# Extract the mutant counts
mutant_counts <- sampled_data$mc

# Calculate mean and variance
mean_mutants <- mean(mutant_counts)
var_mutants <- var(mutant_counts)

# Print results
cat("Mean number of mutants:", mean_mutants, "\n")
cat("Variance of mutants:", var_mutants, "\n")
cat("Variance-to-mean ratio:", var_mutants/mean_mutants, "\n")
```

-   How does the variance compare to the mean?

[The variance (658.1651) is a lot larger than the mean (5.584), with a variance-to-mean ratio of approximately 117.87. This represents extreme overdispersion, as a Poisson distribution would have a variance-to-mean ratio of 1]{style="color:#0066FF;"}

-   What causes this?

[This extreme overdispersion is caused by two key factors:]{style="color:#0066FF;"}

[**The timing of mutations:** Mutations that occur early during the growth phase generate many more descendants than late mutations due to the exponential growth process]{style="color:#0066FF;"}

[**The selection advantage (s=0.01):** Mutant lineages grow faster than wild-type cells, which amplifies the effect of early mutations]{style="color:#0066FF;"}

[These factors create a highly skewed distribution with many samples having few mutants, while a small number of samples have very large numbers of mutants. This results in the observed high variance without substantially affecting the mean]{style="color:#0066FF;"}

4.  In this question, we will consider a population that starts with $K=5\times 10^6$ wild-type individuals (to match the LTEE). The population undergoes exponential growth for one day as explained in question 1. We assume that all mutants have $s=0.01$, and that one mutation event happens on average during the whole growth phase (nmu=1).

-   Simulate 10 replicates of the outcome of this growth phase (with the same initial conditions), using *rflan*. Note: this takes a bit of computational time.
-   Calculate the final fraction of mutants after growth in each case.

```{r}
# Parameters
K <- 5e6  # Initial population size (bottleneck)
n_grow <- 100  # Growth factor
s <- 0.01  # Selection coefficient for mutants
nmu <- 1  # Average number of mutations during growth phase
n_replicates <- 10  # Number of replicate simulations to run

# Install and load the flan package if needed
if (!requireNamespace("flan", quietly = TRUE)) {
  install.packages("flan")
}
library(flan)

# Initialize results
mutant_counts <- numeric(n_replicates)
mutant_fractions <- numeric(n_replicates)
total_cells <- K * n_grow

# Simulate 10 replicates
set.seed(42)  # For reproducibility
for (i in 1:n_replicates) {
  # First, simulate the number of mutation events using a Poisson distribution
  # Since we expect 1 mutation in the whole population
  n_mutations <- rpois(1, nmu)
  
  # For each mutation event, simulate the growth of the mutant lineage
  total_mutants <- 0
  if (n_mutations > 0) {
    # Simulate each mutation event separately
    for (j in 1:n_mutations) {
      sim_data <- rflan(1, mutations = 1, fitness = 1/(1+s), mfn = n_grow)
      total_mutants <- total_mutants + sim_data$mc
    }
  }
  
  mutant_counts[i] <- total_mutants
  mutant_fractions[i] <- total_mutants / total_cells
  
  # Print progress
  cat("Replicate", i, "completed\n")
}

# Display results
print("Mutant counts in each replicate:")
print(mutant_counts)
print("Mutant fractions in each replicate:")
print(format(mutant_fractions, scientific = TRUE))

# Summary statistics
mean_count <- mean(mutant_counts)
sd_count <- sd(mutant_counts)
mean_fraction <- mean(mutant_fractions)
sd_fraction <- sd(mutant_fractions)
cv_fraction <- sd_fraction / mean_fraction

cat("\nSummary statistics:\n")
cat("Mean mutant count:", mean_count, "\n")
cat("SD of mutant count:", sd_count, "\n")
cat("Mean mutant fraction:", format(mean_fraction, scientific = TRUE), "\n")
cat("SD of mutant fraction:", format(sd_fraction, scientific = TRUE), "\n")
cat("Coefficient of variation:", cv_fraction, "\n")

```

[The results show extreme variability in mutant counts across the 10 replicates:]{style="color:#0066FF;"}

[4 replicates produced zero mutants 5 replicates had low mutant counts (1-7) 1 replicate (replicate 2) had 70 mutants, which is dramatically higher than all others]{style="color:#0066FF;"}

[This pattern creates striking statistical properties:\*]{style="color:#0066FF;"}

[Mean mutant count: 9 ]{style="color:#0066FF;"}

[Standard deviation: 21.61 Coefficient of variation: 2.40 (SD/mean)]{style="color:#0066FF;"}

[The standard deviation is more than twice the mean value, indicating high overdispersion. This directly connects to our findings in Question 3, where we observed a variance-to-mean ratio of approximately 118 for mutants arising from single cells. ]{style="color:#0066FF;"}

-   What causes this?

[This variability can be explained by two key stochastic factors:]{style="color:#0066FF;"}

[**Mutation timing:** When a mutation occurs during the growth phase dramatically affects the final number of mutants. Early mutations produce exponentially more descendants than late mutations. ]{style="color:#0066FF;"}

[**Poisson variability in mutation events:** Since mutations are rare events (average of 1 per growth phase across the whole population), some replicates have no mutations while others might have multiple.]{style="color:#0066FF;"}

[The outlier in replicate 2 (70 mutants) likely represents a case where either:]{style="color:#0066FF;"}

[Multiple mutation events occurred by chance, or a mutation occurred very early in the growth phase, allowing the mutant lineage to exploit its selective advantage (s=0.01) over more generations]{style="color:#0066FF;"}

[This extreme variability has important implications for experimental evolution:]{style="color:#0066FF;"}

[Replicate populations can follow dramatically different evolutionary trajectories Beneficial mutations may establish in some replicates but not others, purely by chance Population bottlenecks amplify this variability by randomly sampling from these highly variable distributions]{style="color:#0066FF;"}

[The results illustrate why large numbers of replicates are important in experimental evolution studies to account for the inherent stochasticity in mutation occurrence and establishment.]{style="color:#0066FF;"}

5.  In this question, we will consider a given dilution step, and we will call $k$ the number of mutants that are sampled to form the next bottleneck, which should comprise $K$ individuals.

-   What is the name of the probability distribution that $k$ follows?

[The number of mutants $k$ sampled to form the next bottleneck follows a **binomial distribution**.]{style="color:#0066FF;"}

[This is because:]{style="color:#0066FF;"}

[- We're sampling $K$ individuals from a large population]{style="color:#0066FF;"}

[- Each individual sampled is either a mutant (with probability $x'$) or wild-type (with probability $1-x'$)]{style="color:#0066FF;"}

[- Each sampling event is independent ]{style="color:#0066FF;"}

[- We're interested in the number of successes (mutants) in $K$ trials]{style="color:#0066FF;"}

-   Write the formula for the probability $P(k)$ to obtain a given value of $k$. Note: here, if possible, we recommend using LaTeX for presentation quality.

[The probability of sampling exactly $k$ *mutants when forming a bottleneck of size* $K$ is given by:]{style="color:#0066FF;"}

[$$P(k) = \binom{K}{k} (x')^k (1-x')^{K-k}$$]{style="color:#0066FF;"}

[Where:]{style="color:#0066FF;"}

[- $k$ is the number of mutants sampled ($0 \leq k \leq K$)]{style="color:#0066FF;"}

[- $K$ is the bottleneck size]{style="color:#0066FF;"}

[- $x'$ is the mutant fraction after growth]{style="color:#0066FF;"}

[- $\binom{K}{k} = \frac{K!}{k!(K-k)!}$ is the binomial coefficient]{style="color:#0066FF;"}

[This formula represents the probability mass function of the binomial distribution $B(K, x')$.]{style="color:#0066FF;"}

6.  In this question, we will sample the number $k$ of mutants that exist at the next bottleneck, assuming that $s=0.01$, $K=5\times 10^6$ and $x=0.01$, and taking $t=5$.

-   Sample $N=1000$ different values of $k$.
-   Compute their mean and standard deviation.
-   Plot the histogram of the values obtained.

```{r}
# Parameters
s <- 0.01       # Selection coefficient
K <- 5e6        # Bottleneck size
x <- 0.01       # Initial mutant fraction
t <- 5          # Growth time
N <- 1000       # Number of samples

# Calculate x' (mutant fraction after growth) using the formula from question 2
x_prime <- (x * exp(s * t)) / ((1 - x) + x * exp(s * t))

# Sample k from binomial distribution B(K, x')
k_samples <- rbinom(N, size = K, prob = x_prime)

# Calculate mean and standard deviation
mean_k <- mean(k_samples)
sd_k <- sd(k_samples)

# Print results
cat("Mutant fraction after growth (x'):", x_prime, "\n")
cat("Mean number of mutants:", mean_k, "\n")
cat("Standard deviation:", sd_k, "\n")

# Plot histogram
hist(k_samples, 
     main = "Distribution of Mutants in Next Bottleneck",
     xlab = "Number of mutants (k)",
     col = "#FF7E1D",
     breaks = 30)

# Mean line
abline(v = mean_k, col = "#B300F2", lwd = 2)
```

[The number of mutants sampled for the next bottleneck follows a binomial distribution with parameters $K = 5 \times 10^6$ and probability $x' = 0.01050732$. The mean is 52535 mutants with a standard deviation of 228.73, and the distribution approximates a normal curve as shown in the histogram.]{style="color:#0066FF;"}

7.  In this question, we will simulate the serial passage model. We will neglect new mutations that may happen during the process. Thus, the only mutants are those present initially, and we will assume that they have an initial fraction $x=0.01$.

-   Simulate the serial passage model described above with $s=0.01$, $K=5\times 10^6$ and $x=0.01$, and taking $t=5$, for 300 bottlenecks.
-   Plot the fraction of mutants in the population versus the number of generations in 10 different realizations on the same plot.

```{r}
# Parameters
s <- 0.01       # Selection coefficient
K <- 5e6        # Bottleneck size
x_init <- 0.01  # Initial mutant fraction
t <- 5          # Growth time
n_bottlenecks <- 300  # Number of bottlenecks to simulate
n_realizations <- 10  # Number of different realizations

# Function to calculate mutant fraction after growth
calculate_x_prime <- function(x, s, t) {
  return((x * exp(s * t)) / ((1 - x) + x * exp(s * t)))
}

# Set up matrix to store results - rows are bottlenecks, columns are realizations
x_values <- matrix(0, nrow = n_bottlenecks + 1, ncol = n_realizations)

# Initialize all realizations with the same starting value
x_values[1, ] <- x_init

# Run simulations
set.seed(42)  # For reproducibility
for (j in 1:n_realizations) {
  x <- x_init
  for (i in 1:n_bottlenecks) {
    # Calculate mutant fraction after growth
    x_prime <- calculate_x_prime(x, s, t)
    
    # Sample for the next bottleneck
    k <- rbinom(1, K, x_prime)
    
    # Calculate new mutant fraction
    x <- k / K
    
    # Store the result
    x_values[i + 1, j] <- x
  }
}

# Calculate final mutant frequencies
final_frequencies <- x_values[n_bottlenecks + 1, ]
cat("Final mutant frequencies:", final_frequencies, "\n")
cat("Mean final frequency:", mean(final_frequencies), "\n")

# Calculate how many realizations reach different thresholds
fixation_count <- sum(final_frequencies > 0.99)
high_freq_count <- sum(final_frequencies > 0.5 & final_frequencies <= 0.99)
low_freq_count <- sum(final_frequencies > 0.01 & final_frequencies <= 0.5)
extinction_count <- sum(final_frequencies <= 0.01)

cat("Realizations reaching fixation (>0.99):", fixation_count, "\n")
cat("Realizations reaching high frequency (0.5-0.99):", high_freq_count, "\n")
cat("Realizations maintaining low frequency (0.01-0.5):", low_freq_count, "\n")
cat("Realizations with extinction or near-extinction (<0.01):", extinction_count, "\n")

# Create a color palette
colors <- rainbow(n_realizations)

# Plot the results
plot(0:n_bottlenecks, x_values[, 1], type = "l", col = colors[1],
     xlab = "Number of bottlenecks", ylab = "Mutant fraction",
     ylim = c(0, 1), main = "Serial passage model with selection (s=0.01) & bottleneck (K=5e6)",
     lwd = 2)

# Add other realizations
for (j in 2:n_realizations) {
  lines(0:n_bottlenecks, x_values[, j], col = colors[j], lwd = 2)
}

# Add legend
legend("topleft", legend = paste("Realization", 1:n_realizations),
       col = colors, lty = 1, cex = 0.8, bg = "white")
```

-   What are the characteristics and the long-term outcomes of these trajectories?

[The simulation results show remarkably consistent trajectories with all 10 realizations reaching near-complete fixation (\>0.999) by the end of 300 bottlenecks. This reveals:]{style="color:#0066FF;"}

[**Deterministic dynamics dominate:** The trajectories follow an almost perfect sigmoidal curve with minimal random variation. ]{style="color:#0066FF;"}

[**Selection overwhelmingly outweighs drift:** With Ns = 50,000 (K×s = 5×10\^6 × 0.01), selection is approximately 50,000 times stronger than genetic drift, explaining why stochastic effects are nearly invisible. ]{style="color:#0066FF;"}

[**Minimal sampling variance:** For a binomial process with such large populations, the standard deviation is negligibly small relative to the population size (\~0.022% at maximum variance).]{style="color:#0066FF;"}

-   What is this due to?

[This simulation demonstrates a practically deterministic regime of evolution where:]{style="color:#0066FF;"}

[**Predictable outcomes**: Large population sizes with moderate selection coefficients produce highly predictable evolutionary trajectories. ]{style="color:#0066FF;"}

[**Limited role for chance:** Unlike in smaller populations where drift can lead to loss of beneficial mutations, here selection reliably drives beneficial mutations to fixation.]{style="color:#0066FF;"}

[To observe more stochastic effects and trajectory diversity, we would need a much smaller bottleneck size (e.g., K = 5,000) or a weaker selection coefficient (e.g., s = 0.0001):]{style="color:#0066FF;"}

```{r}
# Parameters
s <- 0.01       # Selection coefficient
K <- 5e3        # Small bottleneck size
x_init <- 0.01  # Initial mutant fraction
t <- 5          # Growth time
n_bottlenecks <- 300  # Number of bottlenecks to simulate
n_realizations <- 10  # Number of different realizations

# Function to calculate mutant fraction after growth
calculate_x_prime <- function(x, s, t) {
  return((x * exp(s * t)) / ((1 - x) + x * exp(s * t)))
}

# Set up matrix to store results - rows are bottlenecks, columns are realizations
x_values <- matrix(0, nrow = n_bottlenecks + 1, ncol = n_realizations)

# Initialize all realizations with the same starting value
x_values[1, ] <- x_init

# Run simulations
set.seed(42)  # For reproducibility
for (j in 1:n_realizations) {
  x <- x_init
  for (i in 1:n_bottlenecks) {
    # Calculate mutant fraction after growth
    x_prime <- calculate_x_prime(x, s, t)
    
    # Sample for the next bottleneck
    k <- rbinom(1, K, x_prime)
    
    # Calculate new mutant fraction
    x <- k / K
    
    # Store the result
    x_values[i + 1, j] <- x
  }
}

# Calculate final mutant frequencies
final_frequencies <- x_values[n_bottlenecks + 1, ]
cat("Final mutant frequencies:", final_frequencies, "\n")
cat("Mean final frequency:", mean(final_frequencies), "\n")

# Calculate how many realizations reach different thresholds
fixation_count <- sum(final_frequencies > 0.99)
high_freq_count <- sum(final_frequencies > 0.5 & final_frequencies <= 0.99)
low_freq_count <- sum(final_frequencies > 0.01 & final_frequencies <= 0.5)
extinction_count <- sum(final_frequencies <= 0.01)

cat("Realizations reaching fixation (>0.99):", fixation_count, "\n")
cat("Realizations reaching high frequency (0.5-0.99):", high_freq_count, "\n")
cat("Realizations maintaining low frequency (0.01-0.5):", low_freq_count, "\n")
cat("Realizations with extinction or near-extinction (<0.01):", extinction_count, "\n")

# Create a color palette
colors <- rainbow(n_realizations)

# Plot the results
plot(0:n_bottlenecks, x_values[, 1], type = "l", col = colors[1],
     xlab = "Number of bottlenecks", ylab = "Mutant fraction",
     ylim = c(0, 1), main = "Serial passage model with selection (s=0.01) & bottleneck (K=5e3)",
     lwd = 2)

# Add other realizations
for (j in 2:n_realizations) {
  lines(0:n_bottlenecks, x_values[, j], col = colors[j], lwd = 2)
}

# Add legend
legend("topleft", legend = paste("Realization", 1:n_realizations),
       col = colors, lty = 1, cex = 0.8, bg = "white")
```
